---
layout: post
author: ᴢʜᴀɴɢ
title: "JVM笔记"
date: 2024-02-26
music-id: 
permalink: /archives/2024-02-28/1
description: "JVM"
---


# JVM
~~~
类加载器的作用是什么?
类加载器(ClassLoader)负责在类加载过程中的字节码获取并加载到内存这一部分。
通过加载字节码数据放入内存转换成byte[],接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。

类的生命周期
加载-连接(验证-准备-解析)-初始化-使用-卸载
验证:验证内容是否满足《Java虚拟机规范》
准备:给静态变量赋初值
解析:将常量池中的符号引用替换成指向内存的直接引用

以下几种方式会导致类的初始化：
1.访问一个类的静态变量或者静态方法，注意变量是final修饰的并且右边是常量不会触发初始化。
2.调用Class.forName(String className)
3.new一个该类的对象时.4.执行Main方法的当前类。

03-初始化 ->会执行静态代码块中的代码，并为静态变量赋值。执行流程与代码流程一致。
几个要点：
1.静态变量的定义使用final关键字,这类变量会在准备阶段直接进行初始化（除非要执行方法）。
2.直接访问父类的静态变量，不会触发子类的初始化。子类的初始化cinit调用之前，会先调用父类的cinit初始化方法。
添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类
~~~
类的双亲委派机制是什么？
~~~
1、当一个类加载器去加载某个类的时候,会自底向上查找是否加载过,如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载,再由顶向下进行加载。
2、应用程序类加载器的父类加载器是扩展类加载器,扩展类加载器的父类加载器是启动类加载器。
3、双亲委派机制的好处有两点:第一是避免恶意代码替换JDK中的核心类库,比如java.lang.String,确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。
~~~
打破双亲委派机制
~~~
打破双亲委派机制的第一种方法: 自定义类加载器
自定义类加载器并且重写loadClass方法,就可以将双亲委派机制的代码去除
Tomcat通过这种方式实现应用之间类隔离

打破双亲委派机制的第二种方法: 线程上下文类加载器
JDBC案例
1、启动类加载器加载DriverManager.
2、在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动。
3、SPI中利用了线程上下文类加载器(应用程序类加载器)去加载类并创建对象。
这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制。
~~~
运行时数据区域(JVM管理的内存)
~~~
JDK6的方法区(永久代)是存放在堆里面的 字符串常量池在方法区里
JDK7字符串常量池从永久代里面被拆出来 放到了堆上 自己占有一块空间
JDK8永久代不再存在 方法区(元空间)是属于直接内存里边的一块区域 字符串常量池依旧是放在堆里边
~~~
#### 垃圾回收(Garbage Collection简称GC)机制。
垃圾回收器主要负责对[堆]上的内存进行回收。

#### 可达性分析算法
~~~
GC Root对象:
1线程Thread对象。
2系统类加载器加载的java.lang.Class对象。
3监视器对象,用来保存同步锁synchronized关键字持有的对象。
4本地方法调用时使用的全局对象。
~~~
软引用
~~~
软引用常用于缓存中

软引用的执行过程如下:
1.将对象使用软引用包装起来, new SoftReference<对象类型>(对象)。
2.内存不足时,虚拟机尝试进行垃圾回收。
3.如果垃圾回收仍不能解决内存不足的问题,回收软引用中的对象。
4.如果依然内存不足,抛出OutOfMemory异常。

# 软引用中的对象如果在内存不足时回收, SoftReference对象本身也需要被回收。
# 如何知道哪些SoftReference对象需要回收呢？
SoftReference提供了一套队列机制：
1、软引用创建时，通过构造器传入引用队列
2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列
3、通过代码遍历引用队列,将SoftReference的强引用删除

弱引用的整体机制和软引用基本一致,区别在于弱引用包含的对象在垃圾回收时,不管内存够不够都会直接被回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用,弱引用主要在ThreadLocal中使用。弱引用对象本身也可以使用引用队列进行回收。
~~~
标记-清除算法
复制算法
标记-整理算法
分代GC
~~~
标记清除算法
1.标记阶段,将所有存活的对象进行标记。Java中使用可达性分析算法,从GC Root开始通过引用链遍历出所有存活对象。
2.清除阶段,从内存中删除没有被标记也就是非存活对象。
实现简单,只需要在第一阶段给每个对象维护标志位,第二阶段删除对象即可。
碎片化问题:由于内存是连续的,所以在对象被删除之后,内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间,很有可能这些内存单元的大小过小无法进行分配。
分配速度慢:由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。

复制算法
1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。
2.在垃圾回收GC阶段，将From中存活对象复制到To空间。
3.将两块空间的From和To名字互换。
吞吐量高:复制算法只需要遍历一次存活对象复制到To空间即可,比标记-整理算法少了一次遍历的过程,因而性能较好,但是不如标记-清除算法,因为标记清除算法不需要进行对象的移动
不会发生碎片化:复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。
内存使用效率低:每次只能让一半的内存空间来为创建对象使用

标记整理算法
标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。
1.标记阶段,将所有存活的对象进行标记。Java中使用可达性分析算法,从GC Root开始通过引用链遍历出所有存活对象。
2.整理阶段,将存活对象移动到堆的一端。清理掉存活对象的内存空间。
内存使用效率高:整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
不会发生碎片化:在整理阶段可以将对象往内存的一侧进行移动,剩下的空间都是可以分配对象的有效空间
整理阶段的效率不高:整理算法有很多种,比如Lisp2整理算法需要对整个堆中的对象搜索3次,整体性能不佳。可以通过TwoFinger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能
~~~
分代GC
~~~
分代垃圾回收将整个内存区域划分为年轻代和老年代：
年轻代：存放存活时间比较短的对象 [Eden区-伊甸园 Survivor-幸存区 S0(From) S1(To)]
老年代：存放存活时间比较长的对象
jdk8
-XX:SurvivorRatio 伊甸园区和幸存区的比例，默认为8新生代1g内存，伊甸园区800MB,SO和S1各100MB    比例调整为4的写法：-XX:SurvivorRatio=4

分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。
随着对象在Eden区越来越多,如果Eden区满,新创建的对象已经无法放入,就会触发年轻代的GC,称为Minor GC或者Young GC
Minor GC会把需要eden中和From需要回收的对象回收,把没有回收的对象放入To区。S0(From) S1(To)
接下来，SO会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。
此时会回收eden区和S1(from)中的对象,并把eden和from区中剩余的对象放入SO
注意:每次Minor GC中都会为对象记录他的年龄,初始值为0,每次GC完加1
如果Minor GC后对象的年龄达到阈值(最大15,默认值和垃圾回收器有关) ,对象就会被晋升至老年代。
当老年代中空间不足,无法放入新的对象时,先尝试minor gc如果还是不足,就会触发Full GC, Full GC会对整个堆进行垃圾回收。
如果Full GC依然无法回收掉老年代的对象,那么当对象继续放入老年代时,就会抛出Out Of Memory异常。
~~~